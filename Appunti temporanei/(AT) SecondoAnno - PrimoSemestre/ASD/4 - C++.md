## ADT Matrice in C e C++

Analizziamo ora come implementare un tipo di dato astratto per una matrice sia in C che in C++. 

La specifica sintattica di questo ADT prevede tre tipi che sono matrice, intero e tipoelem mentre gli operatori fondamentali sono `CreaMatrice()` che restituisce una matrice, `LeggiMatrice(matrice, intero, intero)` che restituisce un tipoelem e `ScriviMatrice(matrice, intero, intero, tipoelem)` che restituisce una matrice.

In C possiamo implementare questa struttura definendo `tipoelem` come `double` e `matrice` come un puntatore a puntatore di `tipoelem`. 
Supponendo di avere dieci righe e dieci colonne la funzione `LeggiMatrice` può essere implementata restituendo semplicemente l'elemento in posizione `M[r,c]` mentre la funzione `ScriviMatrice` assegna il valore `e` alla posizione `M[r,c]` della matrice.

### Requisito di Astrazione

Il requisito di astrazione richiede che le operazioni su un ADT siano indipendenti dalla sua implementazione. 
Consideriamo ad esempio la costruzione di una matrice nulla in C dove una prima implementazione potrebbe utilizzare due cicli annidati che scorrono le righe e le colonne assegnando zero a ogni elemento tramite accesso diretto `M[i,j] = 0`. 
Il problema è che questa implementazione viola il requisito di astrazione perché dipende direttamente dalla realizzazione della matrice quindi l'approccio corretto consiste nell'utilizzare la funzione `ScriviMatrice` all'interno dei cicli scrivendo `ScriviMatrice(M, i, j, 0)`

```c
nulla(matrice & M){
    for (int i=0; i<righe; i++)
        for (int j=0; j<colonne; j++)
            M[i,j] = 0;
}
```

La versione corretta sarebbe:
```c
nulla(matrice & M){
    for (int i=0; i<righe; i++)
        for (int j=0; j<colonne; j++)
            M[i,j] = 0;
}
```

Un ulteriore problema è che le variabili `righe` e `colonne` che sono proprie dell'astrazione matrice non sono protette né incapsulate nella realizzazione e questo significa che possono essere modificate da qualunque parte del codice. Cosa succederebbe se un programmatore scrivesse `righe++` o addirittura `colonne=-1`? Questo porterebbe a comportamenti imprevedibili e potenzialmente catastrofici per il programma.

### Requisito di Protezione

In C è molto facile violare il requisito di protezione come dimostrano diversi esempi pratici. Supponiamo di avere le variabili `matrice A, B`, un array bidimensionale `double C[3][3]`, una variabile `double s` e una variabile `tipoelem e`. Le operazioni `e = LeggiMatrice(A,3,2)` e `ScriviMatrice(B,2,2,e)` non violano il requisito di protezione in quanto utilizzano i tipi corretti.

```c
matrice A, B;
double C[3][3];
double s;
tipoelem e;

// Operazioni corrette
e = LeggiMatrice(A,3,2);
ScriviMatrice(B,2,2,e);

// Violazioni del requisito di protezione
s = LeggiMatrice(A,1,1); // s non è di tipo tipoelem
ScriviMatrice(C,2,2,e); // C non è di tipo matrice
A[3,1] = 7.31; // accesso diretto ad A!!!
righe = righe * 2; // modifica diretta di righe
colonne = -1; // modifica diretta di colonne
e = LeggiMatrice(C,1,1); // C non è di tipo matrice
e = 3.0; // anche tipoelem andrebbe protetto!!!
```
Tuttavia esistono numerosi modi per violare questo requisito come ad esempio l'istruzione `s = LeggiMatrice(A,1,1)` che è problematica perché `s` non è di tipo `tipoelem` oppure `ScriviMatrice(C,2,2,e)` che è errata perché `C` non è di tipo `matrice`. L'accesso diretto `A[3,1] = 7.31` bypassa completamente l'interfaccia dell'ADT mentre la modifica diretta `righe = righe * 2` o `colonne = -1` viola l'incapsulamento. Anche l'istruzione `e = LeggiMatrice(C,1,1)` è scorretta perché `C` non è di tipo `matrice` e infine pure l'assegnamento `e = 3.0` evidenzia che il tipo `tipoelem` stesso andrebbe protetto.

#### Soluzione in C++
Il C++ fornisce tutti gli strumenti necessari per garantire sia il requisito di astrazione che quello di protezione per i nostri ADT e l'ADT matrice può essere realizzata utilizzando una classe che incapsula la struttura dati facendo in modo che i metodi siano applicabili solo su oggetti di tipo matrice.
```c
class matrice {
public:
    matrice(){ // definisce una matrice 5x5
        righe = 5; 
        colonne = 5;
    }
    
    tipoelem LeggiMatrice(int r, int c){
        return M[r,c];
    }
    
    void ScriviMatrice(int r, int c, tipoelem e){
        M[r,c] = e;
    }
    
private:
    double M[10][10];
    int righe, colonne;
};

// Utilizzo
matrice A();
A.ScriviMatrice(3,4,3.0);
A.righe = 10; // non ammesso. Righe è nella parte private, fallisce la compilazione
```
La definizione della classe prevede una parte pubblica e una privata dove il costruttore senza parametri inizializza una matrice 5x5 impostando le variabili `righe` e `colonne` a 5. Il metodo `LeggiMatrice(int r, int c)` restituisce l'elemento in posizione `M[r,c]` mentre il metodo `ScriviMatrice(int r, int c, tipoelem e)` assegna il valore `e` alla posizione `M[r,c]`. La parte privata della classe contiene l'array bidimensionale `double M[10][10]` e le variabili `int righe` e `colonne`.

Per utilizzare questa classe si crea un oggetto `matrice A()` e si invocano i metodi sulla classe con ad esempio `A.ScriviMatrice(3,4,3.0)`. Un tentativo di accesso diretto come `A.righe = 10` non è ammesso perché `righe` si trova nella parte privata della classe e il compilatore genererà un errore di compilazione impedendo questo tipo di violazione.

## Basics - Fondamenti del Linguaggio

### Hello World

Il programma più semplice in C++ è il classico "Hello World" che inizia con la direttiva al preprocessore `#include <iostream>` per includere la libreria per l'input/output. La funzione `main()` è una free function che rappresenta il punto di ingresso del programma e il tipo restituito è un `int` che rappresenta lo status code dove zero indica successo mentre un valore diverso da zero indica un fallimento. Per accedere ai nomi del namespace standard si utilizza il prefisso `std::` mentre l'oggetto `cout` è un oggetto speciale che rappresenta lo schermo e l'operatore `<<` è l'operatore di output che permette di inviare dati verso `cout`.

```c
#include <iostream>

int main() {
    std::cout << "Hello world!" << endl;
    return 0;
}
```
### Parametri a Riga di Comando

È possibile accedere ai parametri forniti a riga di comando definendo la funzione `main` con la seguente firma `int main (int argc, char* argv[])` dove il parametro `argc` rappresenta il numero di parametri passati incluso il nome del programma stesso mentre il parametro `argv` è un array di stringhe in stile C che contiene i parametri effettivi.

Consideriamo un esempio concreto dove se eseguiamo il programma con il comando `./myprog -a myfile.txt` avremo che `argc` vale 3 mentre `argv[0]` contiene la stringa `"./myprog"`, `argv[1]` contiene `"-a"`, `argv[2]` contiene `"myfile.txt"` e `argv[3]` vale 0 che rappresenta il terminatore dell'array.
```c
int main (int argc, char* argv[]) { 
    // argc = numero di parametri
    // argv = array di stringhe
}

// Esempio esecuzione: ./myprog -a myfile.txt
// argc = 3
// argv[0] = "./myprog"
// argv[1] = "-a"
// argv[2] = "myfile.txt"
// argv[3] = 0
```
### Commenti

In C++ esistono due stili per i commenti dove i commenti multi-linea utilizzano la sintassi `/* ... */` e possono estendersi su più righe mentre i commenti su singola riga utilizzano invece la sintassi `//` e si estendono fino alla fine della riga corrente. I commenti sono fondamentali per documentare il codice e spiegare la logica implementativa rendendo il codice più comprensibile sia per noi stessi che per altri sviluppatori.
```c
/* To calculate the final grade, we sum all the weighted
   midterm and homework scores and then divide by the number
   of scores to assign a percentage. This percentage is
   used to calculate a letter grade. */

// To generate a random item, we're going to do the following:
// 1) Put all of the items of the desired rarity on a list
// 2) Calculate a probability for each item based on level and weight factor
// 3) Choose a random number
// 4) Figure out which item that random number corresponds to
// 5) Return the appropriate item
```
### Variabili

Una variabile in C++ è il nome associato a una porzione di memoria e la dichiarazione `int x;` crea una variabile di tipo intero. È possibile stampare il valore di una variabile utilizzando l'istruzione `cout << x;` mentre in C++ le variabili sono note come l-value (left side) ovvero valori che hanno un indirizzo di memoria associato in contrapposizione con gli r-value (right side) che si riferiscono a valori che vengono assegnati a un l-value.
```c
int x;
cout << x;
```
### Variabili Statiche

Un attributo di una classe in C++ può essere dichiarato statico analogamente a quanto avviene in Java e quando un attributo è statico esiste una sola variabile condivisa per tutti gli oggetti della classe. In C++ anche le funzioni possono avere variabili statiche dove una variabile statica all'interno di una funzione viene creata alla prima chiamata della funzione e il suo valore viene mantenuto nelle successive chiamate.

Un esempio pratico è il conteggio del numero di chiamate di una funzione dove definendo una variabile statica `counter` inizializzata a zero e incrementandola ad ogni chiamata è possibile tenere traccia di quante volte la funzione è stata invocata durante l'esecuzione del programma.
```c
void f() {
    static int counter = 0;
    counter++;
    …
}
```
### Assegnamenti e R-value

Gli assegnamenti in C++ seguono regole precise dove l'istruzione `int y;` dichiara `y` come variabile intera e successivamente `y = 4;` assegna il valore 4 a `y`. L'espressione `y = 2 + 5;` valuta prima la somma che risulta 7 e poi assegna questo valore a `y`. Dichiarando una nuova variabile `int x;` e scrivendo `x = y;` il valore 7 viene assegnato a `x` mentre l'assegnamento `x = x;` è perfettamente legale e assegna a `x` il suo stesso valore quindi 7. Infine l'espressione `x = x + 1;` valuta prima la somma `x + 1` che risulta 8 e poi assegna questo nuovo valore a `x`.
```c
int y; // dichiara y come variabile integer
y = 4; // 4 viene assegnato a y
y = 2 + 5; // 2 + 5 è uguale a 7, assegnato a y
int x; // dichiara x come variabile integer
x = y; // y è uguale a 7, assegnato a x
x = x; // x è uguale a 7, assegnato a x
x = x + 1; // x + 1 è uguale a 8, assegnato a x
```
### Cin

L'oggetto `cin` è l'opposto di `cout` e permette di leggere input dalla console. Un programma che chiede all'utente di inserire un numero utilizza `cout` per stampare il messaggio "Enter a number:" e poi dichiara una variabile intera `x` utilizzando `cin >> x;` per leggere il numero dalla console e assegnarlo a `x` per infine stampare il valore inserito con un messaggio appropriato. L'operatore `>>` estrae i dati da `cin` e li assegna alla variabile specificata permettendo l'interazione con l'utente.
```c
#include <iostream>

int main() {
    using namespace std;
    cout << "Enter a number: ";
    int x;
    cin >> x;
    cout << "You entered " << x << " and we do not like "<< x << endl;
    return 0;
}
```
### Funzioni

Le funzioni in C++ sono blocchi di codice riutilizzabili che possono essere chiamati da diverse parti del programma. Una funzione chiamata `doPrint()` di tipo `void` che non restituisce alcun valore può stampare un messaggio sullo schermo mentre la funzione `main()` può invocare `doPrint()` semplicemente scrivendone il nome seguito dalle parentesi. Quando il programma viene eseguito prima viene stampato "Starting main()" poi viene chiamata `doPrint()` che stampa "In doPrint()" e infine viene stampato "Ending main()" prima che il programma termini restituendo zero per indicare l'esecuzione corretta.
```c
// Declaration of function doPrint()
void doPrint()
{
    using namespace std;
    cout << "In doPrint()" << endl;
}

// Declaration of main()
int main()
{
    using namespace std;
    cout << "Starting main()" << endl;
    doPrint(); // chiamata a DoPrint()
    cout << "Ending main()" << endl;
    return 0;
}
```
### Parametri di Funzione

Le funzioni possono accettare parametri per operare su dati diversi rendendo il codice più flessibile e riutilizzabile. Una funzione `add(int x, int y)` restituisce la somma di `x` e `y` mentre una funzione `multiply(int z, int w)` restituisce il prodotto di `z` e `w`. Nella funzione `main` è possibile invocare queste funzioni in vari modi come con valori letterali tipo `add(4, 5)` oppure con variabili come `add(a, b)` dove `a` e `b` sono state precedentemente dichiarate o anche con chiamate annidate come `add(1, multiply(2, 3))` dove il risultato di `multiply(2, 3)` viene passato come secondo parametro ad `add` permettendo di comporre operazioni complesse.
```c
#include <iostream>

int add(int x, int y){
    return x + y;
}

int multiply(int z, int w){
    return z * w;
}

int main(){
    using namespace std;
    cout << add(4, 5) << endl;
    cout << add(3, 6) << endl;
    cout << add(1, 8) << endl;
    
    int a = 3;
    int b = 5;
    cout << add(a, b) << endl;
    cout << add(1, multiply(2, 3)) << endl;
    cout << add(1, add(2, 3)) << endl;
    
    return 0;
}
```
### Forward Declaration

In C++ il compilatore legge il codice dall'alto verso il basso quindi una funzione deve essere dichiarata prima di essere utilizzata altrimenti il compilatore non saprebbe della sua esistenza. Se vogliamo chiamare una funzione `add` nella funzione `main` ma definire il corpo di `add` dopo `main` dobbiamo utilizzare una forward declaration che consiste nel dichiarare il prototipo della funzione prima di `main` scrivendo `int add(int x, int y);`. In questo modo il compilatore sa che la funzione esiste e può compilare correttamente la chiamata in `main` anche se l'implementazione effettiva della funzione viene fornita successivamente nel codice.
```c
#include <iostream>

int add(int x, int y); // forward declaration prototype

int main()
{ 
    using namespace std;
    cout << "The sum of 3 and 4 is: " << add(3, 4) << endl;
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```
## Dati Primitivi

I tipi di dati primitivi in C++ includono `char` per i caratteri singoli, `int`, `short` e `long` per i numeri interi di diverse dimensioni, `double` e `float` per i numeri in virgola mobile e `bool` per i valori booleani. Nel vecchio C++ gli interi venivano spesso utilizzati per rappresentare valori booleani dove qualsiasi valore diverso da zero era considerato vero mentre zero era considerato falso.

Un esempio di questa pratica è dichiarare una variabile intera `a` e leggerla con `cin` per poi utilizzarla in una condizione `if (a)` che è equivalente a scrivere `if (a != 0)` quindi se `a` vale zero la condizione è falsa altrimenti è vera. Similmente quando si lavora con puntatori un'istruzione come `while (p)` è equivalente a `while (p != 0)` dove zero rappresenta il puntatore nullo che in C++98 si indicava con 0 mentre nelle versioni più recenti si usa `nullptr` per rendere il codice più chiaro e sicuro.

```c
// Utilizzo di int come booleano (vecchio C++)
int a;
cin >> a;
if (a) { ... } // equivalent to if (a != 0)

Point* p = list.getFirstPoint();
while (p) { ... } // equivalent to while (p != 0)
// 0 is 'nullptr' for C++98
```