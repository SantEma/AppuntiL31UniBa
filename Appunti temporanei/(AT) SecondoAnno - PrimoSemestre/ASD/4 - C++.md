## ADT Matrice in C e C++

Analizziamo ora come implementare un tipo di dato astratto per una matrice sia in C che in C++. 

La specifica sintattica di questo ADT prevede tre tipi che sono matrice, intero e tipoelem mentre gli operatori fondamentali sono `CreaMatrice()` che restituisce una matrice, `LeggiMatrice(matrice, intero, intero)` che restituisce un tipoelem e `ScriviMatrice(matrice, intero, intero, tipoelem)` che restituisce una matrice.

In C possiamo implementare questa struttura definendo `tipoelem` come `double` e `matrice` come un puntatore a puntatore di `tipoelem`. 
Supponendo di avere dieci righe e dieci colonne la funzione `LeggiMatrice` può essere implementata restituendo semplicemente l'elemento in posizione `M[r,c]` mentre la funzione `ScriviMatrice` assegna il valore `e` alla posizione `M[r,c]` della matrice.

### Requisito di Astrazione

Il requisito di astrazione richiede che le operazioni su un ADT siano indipendenti dalla sua implementazione. 
Consideriamo ad esempio la costruzione di una matrice nulla in C dove una prima implementazione potrebbe utilizzare due cicli annidati che scorrono le righe e le colonne assegnando zero a ogni elemento tramite accesso diretto `M[i,j] = 0`. 
Il problema è che questa implementazione viola il requisito di astrazione perché dipende direttamente dalla realizzazione della matrice quindi l'approccio corretto consiste nell'utilizzare la funzione `ScriviMatrice` all'interno dei cicli scrivendo `ScriviMatrice(M, i, j, 0)`

```c
nulla(matrice & M){
    for (int i=0; i<righe; i++)
        for (int j=0; j<colonne; j++)
            M[i,j] = 0;
}
```

La versione corretta sarebbe:
```c
nulla(matrice & M){
    for (int i=0; i<righe; i++)
        for (int j=0; j<colonne; j++)
            M[i,j] = 0;
}
```

Un ulteriore problema è che le variabili `righe` e `colonne` che sono proprie dell'astrazione matrice non sono protette né incapsulate nella realizzazione e questo significa che possono essere modificate da qualunque parte del codice. Cosa succederebbe se un programmatore scrivesse `righe++` o addirittura `colonne=-1`? Questo porterebbe a comportamenti imprevedibili e potenzialmente catastrofici per il programma.

### Requisito di Protezione

In C è molto facile violare il requisito di protezione come dimostrano diversi esempi pratici. Supponiamo di avere le variabili `matrice A, B`, un array bidimensionale `double C[3][3]`, una variabile `double s` e una variabile `tipoelem e`. Le operazioni `e = LeggiMatrice(A,3,2)` e `ScriviMatrice(B,2,2,e)` non violano il requisito di protezione in quanto utilizzano i tipi corretti.

```c
matrice A, B;
double C[3][3];
double s;
tipoelem e;

// Operazioni corrette
e = LeggiMatrice(A,3,2);
ScriviMatrice(B,2,2,e);

// Violazioni del requisito di protezione
s = LeggiMatrice(A,1,1); // s non è di tipo tipoelem
ScriviMatrice(C,2,2,e); // C non è di tipo matrice
A[3,1] = 7.31; // accesso diretto ad A!!!
righe = righe * 2; // modifica diretta di righe
colonne = -1; // modifica diretta di colonne
e = LeggiMatrice(C,1,1); // C non è di tipo matrice
e = 3.0; // anche tipoelem andrebbe protetto!!!
```
Tuttavia esistono numerosi modi per violare questo requisito come ad esempio l'istruzione `s = LeggiMatrice(A,1,1)` che è problematica perché `s` non è di tipo `tipoelem` oppure `ScriviMatrice(C,2,2,e)` che è errata perché `C` non è di tipo `matrice`. L'accesso diretto `A[3,1] = 7.31` bypassa completamente l'interfaccia dell'ADT mentre la modifica diretta `righe = righe * 2` o `colonne = -1` viola l'incapsulamento. Anche l'istruzione `e = LeggiMatrice(C,1,1)` è scorretta perché `C` non è di tipo `matrice` e infine pure l'assegnamento `e = 3.0` evidenzia che il tipo `tipoelem` stesso andrebbe protetto.

#### Soluzione in C++
Il C++ fornisce tutti gli strumenti necessari per garantire sia il requisito di astrazione che quello di protezione per i nostri ADT e l'ADT matrice può essere realizzata utilizzando una classe che incapsula la struttura dati facendo in modo che i metodi siano applicabili solo su oggetti di tipo matrice.
```c
class matrice {
public:
    matrice(){ // definisce una matrice 5x5
        righe = 5; 
        colonne = 5;
    }
    
    tipoelem LeggiMatrice(int r, int c){
        return M[r,c];
    }
    
    void ScriviMatrice(int r, int c, tipoelem e){
        M[r,c] = e;
    }
    
private:
    double M[10][10];
    int righe, colonne;
};

// Utilizzo
matrice A();
A.ScriviMatrice(3,4,3.0);
A.righe = 10; // non ammesso. Righe è nella parte private, fallisce la compilazione
```
La definizione della classe prevede una parte pubblica e una privata dove il costruttore senza parametri inizializza una matrice 5x5 impostando le variabili `righe` e `colonne` a 5. Il metodo `LeggiMatrice(int r, int c)` restituisce l'elemento in posizione `M[r,c]` mentre il metodo `ScriviMatrice(int r, int c, tipoelem e)` assegna il valore `e` alla posizione `M[r,c]`. La parte privata della classe contiene l'array bidimensionale `double M[10][10]` e le variabili `int righe` e `colonne`.

Per utilizzare questa classe si crea un oggetto `matrice A()` e si invocano i metodi sulla classe con ad esempio `A.ScriviMatrice(3,4,3.0)`. Un tentativo di accesso diretto come `A.righe = 10` non è ammesso perché `righe` si trova nella parte privata della classe e il compilatore genererà un errore di compilazione impedendo questo tipo di violazione.

## Basics - Fondamenti del Linguaggio

### Hello World

Il programma più semplice in C++ è il classico "Hello World" che inizia con la direttiva al preprocessore `#include <iostream>` per includere la libreria per l'input/output. La funzione `main()` è una free function che rappresenta il punto di ingresso del programma e il tipo restituito è un `int` che rappresenta lo status code dove zero indica successo mentre un valore diverso da zero indica un fallimento. Per accedere ai nomi del namespace standard si utilizza il prefisso `std::` mentre l'oggetto `cout` è un oggetto speciale che rappresenta lo schermo e l'operatore `<<` è l'operatore di output che permette di inviare dati verso `cout`.

```c
#include <iostream>

int main() {
    std::cout << "Hello world!" << endl;
    return 0;
}
```
### Parametri a Riga di Comando

È possibile accedere ai parametri forniti a riga di comando definendo la funzione `main` con la seguente firma `int main (int argc, char* argv[])` dove il parametro `argc` rappresenta il numero di parametri passati incluso il nome del programma stesso mentre il parametro `argv` è un array di stringhe in stile C che contiene i parametri effettivi.

Consideriamo un esempio concreto dove se eseguiamo il programma con il comando `./myprog -a myfile.txt` avremo che `argc` vale 3 mentre `argv[0]` contiene la stringa `"./myprog"`, `argv[1]` contiene `"-a"`, `argv[2]` contiene `"myfile.txt"` e `argv[3]` vale 0 che rappresenta il terminatore dell'array.
```c
int main (int argc, char* argv[]) { 
    // argc = numero di parametri
    // argv = array di stringhe
}

// Esempio esecuzione: ./myprog -a myfile.txt
// argc = 3
// argv[0] = "./myprog"
// argv[1] = "-a"
// argv[2] = "myfile.txt"
// argv[3] = 0
```
### Commenti

In C++ esistono due stili per i commenti dove i commenti multi-linea utilizzano la sintassi `/* ... */` e possono estendersi su più righe mentre i commenti su singola riga utilizzano invece la sintassi `//` e si estendono fino alla fine della riga corrente. I commenti sono fondamentali per documentare il codice e spiegare la logica implementativa rendendo il codice più comprensibile sia per noi stessi che per altri sviluppatori.
```c
/* To calculate the final grade, we sum all the weighted
   midterm and homework scores and then divide by the number
   of scores to assign a percentage. This percentage is
   used to calculate a letter grade. */

// To generate a random item, we're going to do the following:
// 1) Put all of the items of the desired rarity on a list
// 2) Calculate a probability for each item based on level and weight factor
// 3) Choose a random number
// 4) Figure out which item that random number corresponds to
// 5) Return the appropriate item
```
### Variabili

Una variabile in C++ è il nome associato a una porzione di memoria e la dichiarazione `int x;` crea una variabile di tipo intero. È possibile stampare il valore di una variabile utilizzando l'istruzione `cout << x;` mentre in C++ le variabili sono note come l-value (left side) ovvero valori che hanno un indirizzo di memoria associato in contrapposizione con gli r-value (right side) che si riferiscono a valori che vengono assegnati a un l-value.
```c
int x;
cout << x;
```
### Variabili Statiche

Un attributo di una classe in C++ può essere dichiarato statico analogamente a quanto avviene in Java e quando un attributo è statico esiste una sola variabile condivisa per tutti gli oggetti della classe. In C++ anche le funzioni possono avere variabili statiche dove una variabile statica all'interno di una funzione viene creata alla prima chiamata della funzione e il suo valore viene mantenuto nelle successive chiamate.

Un esempio pratico è il conteggio del numero di chiamate di una funzione dove definendo una variabile statica `counter` inizializzata a zero e incrementandola ad ogni chiamata è possibile tenere traccia di quante volte la funzione è stata invocata durante l'esecuzione del programma.
```c
void f() {
    static int counter = 0;
    counter++;
    …
}
```
### Assegnamenti e R-value

Gli assegnamenti in C++ seguono regole precise dove l'istruzione `int y;` dichiara `y` come variabile intera e successivamente `y = 4;` assegna il valore 4 a `y`. L'espressione `y = 2 + 5;` valuta prima la somma che risulta 7 e poi assegna questo valore a `y`. Dichiarando una nuova variabile `int x;` e scrivendo `x = y;` il valore 7 viene assegnato a `x` mentre l'assegnamento `x = x;` è perfettamente legale e assegna a `x` il suo stesso valore quindi 7. Infine l'espressione `x = x + 1;` valuta prima la somma `x + 1` che risulta 8 e poi assegna questo nuovo valore a `x`.
```c
int y; // dichiara y come variabile integer
y = 4; // 4 viene assegnato a y
y = 2 + 5; // 2 + 5 è uguale a 7, assegnato a y
int x; // dichiara x come variabile integer
x = y; // y è uguale a 7, assegnato a x
x = x; // x è uguale a 7, assegnato a x
x = x + 1; // x + 1 è uguale a 8, assegnato a x
```
### Cin

L'oggetto `cin` è l'opposto di `cout` e permette di leggere input dalla console. Un programma che chiede all'utente di inserire un numero utilizza `cout` per stampare il messaggio "Enter a number:" e poi dichiara una variabile intera `x` utilizzando `cin >> x;` per leggere il numero dalla console e assegnarlo a `x` per infine stampare il valore inserito con un messaggio appropriato. L'operatore `>>` estrae i dati da `cin` e li assegna alla variabile specificata permettendo l'interazione con l'utente.
```c
#include <iostream>

int main() {
    using namespace std;
    cout << "Enter a number: ";
    int x;
    cin >> x;
    cout << "You entered " << x << " and we do not like "<< x << endl;
    return 0;
}
```
### Funzioni

Le funzioni in C++ sono blocchi di codice riutilizzabili che possono essere chiamati da diverse parti del programma. Una funzione chiamata `doPrint()` di tipo `void` che non restituisce alcun valore può stampare un messaggio sullo schermo mentre la funzione `main()` può invocare `doPrint()` semplicemente scrivendone il nome seguito dalle parentesi. Quando il programma viene eseguito prima viene stampato "Starting main()" poi viene chiamata `doPrint()` che stampa "In doPrint()" e infine viene stampato "Ending main()" prima che il programma termini restituendo zero per indicare l'esecuzione corretta.
```c
// Declaration of function doPrint()
void doPrint()
{
    using namespace std;
    cout << "In doPrint()" << endl;
}

// Declaration of main()
int main()
{
    using namespace std;
    cout << "Starting main()" << endl;
    doPrint(); // chiamata a DoPrint()
    cout << "Ending main()" << endl;
    return 0;
}
```
### Parametri di Funzione
Le funzioni possono accettare parametri per operare su dati diversi rendendo il codice più flessibile e riutilizzabile. Una funzione `add(int x, int y)` restituisce la somma di `x` e `y` mentre una funzione `multiply(int z, int w)` restituisce il prodotto di `z` e `w`. Nella funzione `main` è possibile invocare queste funzioni in vari modi come con valori letterali tipo `add(4, 5)` oppure con variabili come `add(a, b)` dove `a` e `b` sono state precedentemente dichiarate o anche con chiamate annidate come `add(1, multiply(2, 3))` dove il risultato di `multiply(2, 3)` viene passato come secondo parametro ad `add` permettendo di comporre operazioni complesse.
```c
#include <iostream>

int add(int x, int y){
    return x + y;
}

int multiply(int z, int w){
    return z * w;
}

int main(){
    using namespace std;
    cout << add(4, 5) << endl;
    cout << add(3, 6) << endl;
    cout << add(1, 8) << endl;
    
    int a = 3;
    int b = 5;
    cout << add(a, b) << endl;
    cout << add(1, multiply(2, 3)) << endl;
    cout << add(1, add(2, 3)) << endl;
    
    return 0;
}
```
### Forward Declaration

In C++ il compilatore legge il codice dall'alto verso il basso quindi una funzione deve essere dichiarata prima di essere utilizzata altrimenti il compilatore non saprebbe della sua esistenza. Se vogliamo chiamare una funzione `add` nella funzione `main` ma definire il corpo di `add` dopo `main` dobbiamo utilizzare una forward declaration che consiste nel dichiarare il prototipo della funzione prima di `main` scrivendo `int add(int x, int y);`. In questo modo il compilatore sa che la funzione esiste e può compilare correttamente la chiamata in `main` anche se l'implementazione effettiva della funzione viene fornita successivamente nel codice.
```c
#include <iostream>

int add(int x, int y); // forward declaration prototype

int main()
{ 
    using namespace std;
    cout << "The sum of 3 and 4 is: " << add(3, 4) << endl;
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```
## Dati Primitivi
I tipi di dati primitivi in C++ includono `char` per i caratteri singoli, `int`, `short` e `long` per i numeri interi di diverse dimensioni, `double` e `float` per i numeri in virgola mobile e `bool` per i valori booleani. Nel vecchio C++ gli interi venivano spesso utilizzati per rappresentare valori booleani dove qualsiasi valore diverso da zero era considerato vero mentre zero era considerato falso.

Un esempio di questa pratica è dichiarare una variabile intera `a` e leggerla con `cin` per poi utilizzarla in una condizione `if (a)` che è equivalente a scrivere `if (a != 0)` quindi se `a` vale zero la condizione è falsa altrimenti è vera. Similmente quando si lavora con puntatori un'istruzione come `while (p)` è equivalente a `while (p != 0)` dove zero rappresenta il puntatore nullo che in C++98 si indicava con 0 mentre nelle versioni più recenti si usa `nullptr` per rendere il codice più chiaro e sicuro.

```c
// Utilizzo di int come booleano (vecchio C++)
int a;
cin >> a;
if (a) { ... } // equivalent to if (a != 0)

Point* p = list.getFirstPoint();
while (p) { ... } // equivalent to while (p != 0)
// 0 is 'nullptr' for C++98
```
## Reference

Un reference in C++ è un nome alternativo per identificare un oggetto, essenzialmente un alias che deve essere inizializzato quando viene creato e, una volta inizializzato, non può essere cambiato per riferirsi a un altro oggetto. Non esistono reference null, il che li rende più sicuri dei puntatori in certi contesti. Quando si dichiara `int ival = 1024; int& refval = ival;`, l'indirizzo di `refval` viene impostato all'indirizzo di `ival`. Se poi si esegue `refval += 2;`, il valore di `refval` (e quindi anche di `ival`) diventerà 1026.

## Passaggio di Parametri

I parametri a una funzione in C++ sono passati per valore di default, il che significa che viene creata una copia del valore del parametro reale. Se si vuole modificare il valore del parametro reale all'interno della funzione, si può passare l'argomento per riferimento. Ad esempio, la funzione `void swap(int &v1, int &v2) { int tmp = v2; v2 = v1; v1 = tmp; }` permette di scambiare effettivamente i valori di due variabili passate dal chiamante. Quando nel `main()` si chiama `swap(i, j)` con `int i = 10; int j = 20;`, i valori di `i` e `j` verranno effettivamente scambiati.

Il passaggio per riferimento viene utilizzato anche per passare oggetti di grandi dimensioni senza farne una copia, migliorando l'efficienza. La vecchia modalità `bool isShorter(string s1, string s2)` effettua una copia delle stringhe, mentre la nuova modalità `bool isShorter(const string& s1, const string& s2) { return s1.size() < s2.size(); }` non effettua copie. La parola chiave `const` è essenziale quando non si vuole modificare l'oggetto: senza `const`, non si potrebbero passare stringhe costanti e si potrebbe inavvertitamente cambiare lo stato dell'oggetto nella funzione. La regola generale è di passare sempre per `const` reference a meno che non si necessiti di modificare il parametro reale.

## Puntatori

Un puntatore punta a una locazione di memoria e conserva l'indirizzo di quella locazione, potendo far riferimento a qualsiasi cosa. Si dichiara con un asterisco tra il tipo e il nome della variabile: `int* ip1;` o equivalentemente `int *ip1`. Per inizializzare un puntatore a null si usa `Point* p = nullptr;`, dove `nullptr` è il puntatore nullo introdotto in C++11 (nel C++98 si usava 0). Per ottenere l'indirizzo di una variabile si usa l'operatore `&`: se `int ival = 1024;`, allora `ival` contiene 1024 mentre `&ival` contiene l'indirizzo di `ival`. Assegnando `int* ip2 = &ival;`, `ip2` contiene l'indirizzo mentre `*ip2` contiene 1024.

## Dereferenziare

Il contenuto della memoria a cui punta un puntatore è accessibile con l'operatore `*` (dereferenziazione). Con `int ival = 1024; int* ip2 = &ival;`, l'istruzione `cout << *ip2 << endl;` stampa 1024, e si può modificare il valore con `*ip2 = 1025;`. Le differenze principali tra puntatori e riferimenti sono che i puntatori possono essere dereferenziati mentre i riferimenti no, i puntatori possono essere indefiniti o null mentre i riferimenti no, e i puntatori possono essere cambiati per puntare ad altro mentre i riferimenti no.

## Alias di Tipi

Si può definire un nuovo nome di tipo come sinonimo di un nome di tipo già esistente. Tradizionalmente si usa `typedef`, ma nel nuovo standard C++11 esiste la dichiarazione di alias `using`. Ad esempio, `using counter_type = unsigned long;` è equivalente a `typedef unsigned long counter_type;`. Altri esempi includono `using table_type = std::vector<int>;` che è equivalente a `typedef std::vector<int> table_type;`.

## Auto (C++11)

La parola chiave `auto` dice al compilatore di dedurre il tipo da un inizializzatore, utile quando i nomi di tipo sono lunghi da scrivere o difficili da ricordare. Per esempio, con `vector<int> v;` l'istruzione `auto it = v.begin();` fa sì che il compilatore deduca che `it` è di tipo `vector<int>::iterator`. Non si dovrebbe usare `auto` quando il tipo è ovvio, come in `auto sum = 0;` che è inutile perché `sum` è chiaramente un `int`.

## Array

Bjarne Stroustrup ha affermato che "il concetto di array del C è rotto e irreparabile", infatti i programmi C++ moderni normalmente usano vettori invece degli array built-in. Non esistono verifiche sulla indicizzazione a runtime, quindi con un indice errato è possibile accedere e distruggere un elemento fuori dall'array. Esistono due modi di allocare array: sullo stack o sullo heap.

Per un array allocato sullo stack, si scrive `void f() { int a = 5; int x[3]; for (size_t i = 0; i != 3; ++i) { x[i] = (i + 1) * (i + 1); } }`, dove la dimensione deve essere una costante a tempo di compilazione. In molti casi quando si usa il nome di un array, il compilatore sostituisce un puntatore al primo elemento dell'array, quindi le assegnazioni `int* px1 = x;` e `int* px2 = &x[0];` sono equivalenti.

È possibile usare puntatori per accedere agli elementi di un array, essendo i puntatori gli iteratori per gli array. Con `int x[] = {0, 2, 4, 6, 8};` si può iterare con `for (int* px = x; px != x + 5; ++px) { cout << *px << endl; }`. Quando si incrementa un puntatore, gli incrementi sono in misura del tipo di dato indirizzato: `px + 1` significa `px + sizeof(T)` per un array di tipo `T`. Si possono anche sottrarre due puntatori per ottenere il numero di elementi tra loro.

Con C++11 sono state introdotte le funzioni `begin` e `end` che possono essere usate anche con gli array: `for (int* px = begin(x); px != end(x); ++px) { cout << *px << endl; }`.

Per gli array su heap, simili agli array in Java, si alloca memoria dinamica: `void g(size_t n) { int a; int* px = new int[n]; for (size_t i = 0; i < n; ++i) { px[i] = (i + 1) * (i + 1); } delete[] px; }`. È importante notare che a un heap-allocated array si accede con puntatori, non contiene informazioni sulla sua lunghezza, le funzioni `begin()` e `end()` non possono essere utilizzate, e `delete[]` è necessaria per cancellare l'array (altrimenti gli oggetti nell'array non verranno distrutti).

## Casting

In C++ la conversione di tipo può essere implicita come in `d = 35.67; int x = d;` dove `x` diventa 35, ma si dovrebbe usare un cast esplicito: `int x = static_cast<int>(d);`. Altri cast disponibili sono `dynamic_cast<type>(pointer)` per il downcasting in una gerarchia di ereditarietà, `const_cast<type>(variable)` che rimuove la constness da una variabile (non spesso usato), e `reinterpret_cast<type>(expr)` che reinterpreta il pattern di bit in modo diverso, usato nella programmazione di basso livello. Il casting alla C (e alla Java) come `(int) d` è permesso in C++ ma non dovrebbe essere usato.

## Vector

La classe `vector` è una classe template per la memorizzazione di elementi di tipo arbitrario. Un esempio base è: `#include <iostream> #include <vector> #include <string> using namespace std; int main() { vector<string> v; string word; while (cin >> word) v.push_back(word); for (int i = v.size() - 1; i >= 0; --i) cout << v[i] << endl; }`. Un vector è inizialmente vuoto, gli elementi vengono aggiunti in coda con `push_back`, lo spazio viene allocato automaticamente, si accede agli elementi con `v[index]`, i vector possono essere copiati con `V1 = V2` e confrontati con `V1 == V2`.

## Iteratori

I vector sono parte della standard library e di solito si usano gli iteratori per accedere ai loro elementi. Un iteratore "punta" a uno degli elementi della collection o a una posizione immediatamente successiva all'ultimo elemento. Si può dereferenziare con `*` per accedere all'elemento e incrementare con `++` per passare al successivo. I container hanno i metodi `begin()` e `end()` che restituiscono iteratori.

Per scansionare un vettore si può scrivere `for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) *it = 0;`, meglio con auto in C++11: `for (auto it = v.begin(); it != v.end(); ++it) *it = 0;`, o ancor meglio con un for range-based: `for (int& e : v) e = 0;`.

Gli iteratori di vector supportano operazioni aritmetiche. Per trovare il primo numero negativo nella seconda metà del vector: `auto it = v.begin() + v.size() / 2; while (it != v.end() && *it >= 0) ++it; if (it != v.end()) cout << "Found at index " << it - v.begin() << endl; else cout << "Not found" << endl;`.

Un normale iteratore può essere utilizzato per leggere e scrivere elementi, mentre un `const_iterator` può solo leggere. I metodi `cbegin()` e `cend()` (C++11) restituiscono iteratori const. Quando un container è costante, anche `begin()` e `end()` restituiscono iteratori costanti.

## Classi

Una classe Point dove le coordinate non possono essere negative si definisce come: `class Point { public: using coord_t = unsigned int; Point(coord_t ix, coord_t iy); coord_t get_x() const; coord_t get_y() const; void move_to(coord_t new_x, coord_t new_y); private: coord_t x; coord_t y; };`. L'alias di tipo pubblico permette agli utenti di usare quel nome, e le funzioni accessorie che non cambiano lo stato dell'oggetto dovrebbero essere dichiarate `const`.

L'implementazione delle funzioni membro è: `Point::Point(coord_t ix, coord_t iy) : x(ix), y(iy) {} Point::coord_t Point::get_x() const { return x; } Point::coord_t Point::get_y() const { return y; } void Point::move_to(coord_t new_x, coord_t new_y) { x = new_x; y = new_y; }`.

Il puntatore `this` punta all'oggetto corrente. Una `struct` è come una classe ma con membri pubblici di default. Per riferimenti circolari tra classi serve una forward declaration: `class B; class A { B* pb; }; class B { A* pa; };`.

Come esempio pratico, una classe Fibonacci può essere implementata con caching usando `mutable` per permettere a funzioni `const` di modificare membri interni: `class Fibonacci { public: Fibonacci(); unsigned int value(unsigned int n) const; private: mutable vector<unsigned int> values; };`. La keyword `mutable` permette alla funzione `value`, dichiarata `const`, di modificare il vettore `values` per implementare il caching.

## Inizializzazioni

I membri di una classe possono essere inizializzati in tre modi: direct initialization (`int x = 123;` nuovo in C++11), constructor initializer (`A::A(int ix) : x(ix) {}`), o assignment (`A::A(int ix) { x = ix; }`). Il constructor initializer è da preferire, e i membri che sono riferimenti o `const` devono essere inizializzati, non possono essere assegnati.

Con C++11, un costruttore può delegare le inizializzazioni ad altri costruttori: `class Complex { public: Complex(double r, double i) : re(r), im(i) {} Complex(double r) : Complex(r, 0) {} Complex() : Complex(0, 0) {} private: double re; double im; };`.

## Membri Statici

Una classe che conta il numero di oggetti creati usa membri statici: `class Counted { public: Counted() { ++nbrObj; } ~Counted() { --nbrObj; } static unsigned int getNbrObj() { return nbrObj; } private: static unsigned int nbrObj; }; unsigned int Counted::nbrObj = 0;`. Un membro statico deve essere inizializzato fuori dalla classe.

## New e Delete

Gli operatori `new` e `delete` vengono tradotti in chiamate a `void* operator new(size_t bytes);` e `void operator delete(void* p) noexcept;`. Quando si scrive `Point* p = new Point(10, 20);`, il sistema alloca memoria raw e inizializza l'oggetto. Con `delete p;`, distrugge l'oggetto e libera la memoria.

## Copia di Oggetti

Gli oggetti sono copiati in diversi casi: inizializzazioni (`Person p1("Bob"); Person p2(p1);`), passaggio per valore, assegnamento (`p4 = p1;`), e funzioni che restituiscono un valore. L'inizializzazione (`Person p3 = p1;`) è diversa dall'assegnamento (`p4 = p1;`): la prima usa il costruttore di copia `Classname(const Classname&)`, la seconda usa l'operatore di assegnamento `Classname& operator=(const Classname&)`.

Quando non presenti, il compilatore sintetizza versioni che effettuano la copia membro a membro, sufficienti per classi senza risorse dinamiche.

## Gestione della Memoria Dinamica

Una classe String che alloca memoria dinamicamente necessita di gestione speciale: `class String { public: String(const char* s) : chars(new char[strlen(s) + 1]) { strcpy(chars, s); } ~String() { delete[] chars; } private: char *chars; };`.

Senza un costruttore di copia personalizzato, la copia membro a membro del compilatore causa problemi: due oggetti puntano alla stessa area di memoria, causando double delete quando vengono distrutti. La soluzione è implementare un costruttore di copia che fa una deep copy: `String(const String& rhs): chars(new char[strlen(rhs.chars) + 1]) { strcpy(chars, rhs.chars); }`.

Similmente, l'operatore di assegnamento deve essere sovraccaricato per evitare memory leak e double delete: `String& String::operator=(const String& rhs) { if (&rhs == this) { return *this; } delete[] chars; chars = new char[strlen(rhs.chars) + 1]; strcpy(chars, rhs.chars); return *this; }`. È importante verificare gli auto-assegnamenti, cancellare il vecchio stato, e restituire `*this`.

## Move Semantics (C++11)

Quando l'oggetto sorgente di una copia non verrà più usato (valori temporanei), si può implementare il costruttore di spostamento per evitare copie inutili. I valori temporanei si riconoscono in situazioni come `String s3 = s1 + s2;` dove il risultato di `+` è temporaneo.

Un lvalue è persistente (variabili) mentre un rvalue non lo è. Con rvalue reference (`String&& srr = s1 + s2;`) si può scrivere il costruttore di spostamento: `String(String&& rhs) noexcept : chars(rhs.chars) { rhs.chars = nullptr; }` e l'operatore di assegnamento per movimento: `String& operator=(String&& rhs) noexcept { if (&rhs == this) { return *this; } delete[] chars; chars = rhs.chars; rhs.chars = nullptr; }`.

## Idiomi di Costruzione

Una classe che gestisce risorse dinamiche deve implementare la "Rule of Five": distruttore, costruttore di copia, operatore di assegnamento, costruttore di spostamento, e operatore di assegnamento per movimento. Il costruttore di copia (`ClassName(const ClassName& rhs)`) si attiva creando un nuovo oggetto da uno esistente. L'operatore di assegnamento (`ClassName& operator=(const ClassName& rhs)`) si attiva assegnando a un oggetto esistente. Il costruttore di spostamento (`ClassName(ClassName&& rhs) noexcept`) si attiva creando da un temporaneo. L'operatore di assegnamento per movimento (`ClassName& operator=(ClassName&& rhs) noexcept`) si attiva assegnando da un temporaneo.

## Vettori di Oggetti

Con i vector di oggetti: `vector<Person> v; Person p1("Bob"); v.push_back(p1);` copia l'oggetto, mentre `v.push_back(Person("Alice"));` sposta l'oggetto temporaneo. Per iterare: `for (const auto& p : v) { cout << p.getName() << endl; }`.

Con vettori di puntatori: `vector<Person*> pv; Person* p = new Person("Bob"); pv.push_back(p);` e poi ricordarsi di deallocare: `for (auto pptr : pv) { delete pptr; }`.

## Memory Leaks

Un memory leak si verifica quando memoria allocata dinamicamente non viene deallocata. Può accadere dimenticando di deallocare (`void doSomething(){ int *pnValue = new int; }`), riassegnando puntatori (`pnValue = &nValue;`), o con doppia allocazione (`pnValue = new int; pnValue = new int;`).

## Sovraccarico di Funzioni

Funzioni con lo stesso nome ma parametri differenti permettono di gestire tipi diversi: `int add(int nX, int nY){ return nX + nY; } double add(double nX, double nY){ return nX + nY; }` o numero di parametri diverso: `double add(double nX, double nY, double nZ){ return nX + nY + nZ; }`.

## Puntatori a Funzione

I puntatori a funzione puntano a funzioni invece che a variabili. La dichiarazione `int (*pFoo)();` crea un puntatore a una funzione senza parametri che restituisce un int. Sono utili per passare funzioni come parametri, come in un algoritmo di ordinamento che accetta la funzione di confronto: `void selectionSort(int *anArray, int nSize, bool (*pComparison)(int, int))`. Si può chiamare con `selectionSort(anArray, 9, ascending);` o `selectionSort(anArray, 9, descending);` per ordinamenti diversi.

## Funzioni Template

Per evitare di riscrivere la stessa logica per tipi diversi, si usano i template: `template <typename Type> Type max(Type tX, Type tY){ return (tX > tY) ? tX : tY; }`. Il compilatore genera automaticamente le versioni necessarie: `int nValue = max(3, 7);` genera una versione per int, `double dValue = max(6.34, 18.523);` per double. Il tipo deve supportare l'operatore richiesto (in questo caso `>`).

## Classi Template

Le classi template permettono di creare contenitori generici. Una classe Array generica: `template <typename T> class Array{ private: int m_nLength; T *m_ptData; public: Array(int nLength) { m_ptData= new T[nLength]; m_nLength = nLength; } ~Array() { delete[] m_ptData; } T& operator[](int nIndex) { assert(nIndex >= 0 && nIndex < m_nLength); return m_ptData[nIndex]; } int GetLength(){return m_nLength;} };`. Si usa come `Array<int> anArray(12); Array<double> adArray(12);`.

È possibile specializzare template per tipi specifici. Per esempio, per stampare double in formato scientifico: `void Storage<double>::Print() { std::cout << std::scientific << m_tValue << std::endl; }`.

## Eccezioni

Il C++ gestisce le eccezioni con `throw`, `try` e `catch`. Si lancia un'eccezione con `throw`: può essere un valore letterale (`throw -1;`), una stringa (`throw "Error message";`), o un oggetto. Le eccezioni si catturano in blocchi try-catch: `try { if (dX < 0.0) throw "Can not take sqrt of negative number"; cout << "The sqrt of " << dX << " is " << sqrt(dX) << endl; } catch (char* strException) { cerr << "Error: " << strException << endl; }`.

Lo schema chiamante/chiamato prevede che la funzione chiamata lanci eccezioni per condizioni di errore, mentre la funzione chiamante le cattura in un blocco try-catch, gestisce l'errore, e può riprovare l'operazione in un loop fino al successo.

## Stringhe in C++

Le stringhe C++ (`#include <string>`) offrono molte funzionalità. Si creano con `string sSource("012345678");`, si ottiene la lunghezza con `sSource.length()`, si verifica se vuota con `sSource.empty()`, si accede ai caratteri con `sSource[0]`.

L'assegnamento può avvenire in vari modi: `sString = string("One");`, `sString.assign(sTwo);`, `sString = "Three";`, o assegnamento a catena `sString = sOther = "Six";`. Si può assegnare una sottostringa con `sDest.assign(sSource, 2, 4);` che assegna 4 caratteri a partire dall'indice 2.

La concatenazione si fa con `+=` o `append()`: `sString += string(" two"); sString.append(sThree);`. Si può appendere una sottostringa: `sString.append(sTemp, 3, 5);`. L'inserimento in una posizione specifica: `sString.insert(2, string("bbbb"));` inserisce "bbbb" all'indice 2.