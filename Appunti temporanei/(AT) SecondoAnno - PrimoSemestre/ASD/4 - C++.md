## ADT Matrice in C e C++

Analizziamo  come implementare un tipo di dato astratto (ADT) per una matrice sia in C che in C++. La specifica sintattica di questo ADT prevede tre tipi: matrice, intero e tipoelem. Gli operatori fondamentali sono `CreaMatrice()` che restituisce una matrice, `LeggiMatrice(matrice, intero, intero)` che restituisce un tipoelem, e `ScriviMatrice(matrice, intero, intero, tipoelem)` che restituisce una matrice.

In C è possibile implementare questa struttura definendo `tipoelem` come `double` e `matrice` come un puntatore a puntatore di `tipoelem`. Supponendo di avere dieci righe e dieci colonne, la funzione `LeggiMatrice` può essere implementata restituendo l'elemento in posizione `M[r,c]`, mentre la funzione `ScriviMatrice` assegna il valore `e` alla posizione `M[r,c]` della matrice.

### Requisito di Astrazione
Il requisito di astrazione richiede che le operazioni su un ADT siano indipendenti dalla sua implementazione. Consideriamo ad esempio la costruzione di una matrice nulla in C. Una prima implementazione potrebbe utilizzare due cicli annidati che scorrono le righe e le colonne, assegnando zero a ogni elemento tramite accesso diretto `M[i,j] = 0`. Tuttavia questa implementazione viola il requisito di astrazione perché dipende direttamente dalla realizzazione della matrice. L'approccio corretto consiste nell'utilizzare la funzione `ScriviMatrice` all'interno dei cicli, scrivendo `ScriviMatrice(M, i, j, 0)`.

Un ulteriore problema è che le variabili `righe` e `colonne`, che sono proprie dell'astrazione matrice, non sono protette né incapsulate nella realizzazione. Questo significa che possono essere modificate da qualunque parte del codice. 
Cosa succederebbe se un programmatore scrivesse `righe++` o addirittura `colonne=-1`? Questo porterebbe a comportamenti imprevedibili e potenzialmente catastrofici per il programma.

### Requisito di Protezione

In C è molto facile violare il requisito di protezione, come dimostrano diversi esempi. Supponiamo di avere le variabili `matrice A, B`, un array bidimensionale `double C[3][3]`, una variabile `double s` e una variabile `tipoelem e`. Le operazioni `e = LeggiMatrice(A,3,2)` e `ScriviMatrice(B,2,2,e)` non violano il requisito di protezione in quanto utilizzano i tipi corretti.

Tuttavia esistono numerosi modi per violare questo requisito. L'istruzione `s = LeggiMatrice(A,1,1)` è problematica perché `s` non è di tipo `tipoelem`. L'istruzione `ScriviMatrice(C,2,2,e)` è errata perché `C` non è di tipo `matrice`. L'accesso diretto `A[3,1] = 7.31` bypassa completamente l'interfaccia dell'ADT. La modifica diretta `righe = righe * 2` o `colonne = -1` viola l'incapsulamento. L'istruzione `e = LeggiMatrice(C,1,1)` è scorretta perché `C` non è di tipo `matrice`. Infine, anche l'assegnamento `e = 3.0` evidenzia che il tipo `tipoelem` stesso andrebbe protetto.

### Soluzione in C++

Il C++ fornisce tutti gli strumenti necessari per garantire sia il requisito di astrazione che quello di protezione per i nostri ADT. L'ADT matrice può essere realizzata utilizzando una classe che incapsula la struttura dati. In questo modo i metodi saranno applicabili solo su oggetti di tipo matrice.

La definizione della classe prevede una parte pubblica e una privata. Il costruttore senza parametri inizializza una matrice 5x5 impostando le variabili `righe` e `colonne` a 5. Il metodo `LeggiMatrice(int r, int c)` restituisce l'elemento in posizione `M[r,c]`, mentre il metodo `ScriviMatrice(int r, int c, tipoelem e)` assegna il valore `e` alla posizione `M[r,c]`. La parte privata della classe contiene l'array bidimensionale `double M[10][10]` e le variabili `int righe` e `colonne`.

Per utilizzare questa classe si crea un oggetto `matrice A()` e si invocano i metodi sulla classe, ad esempio `A.ScriviMatrice(3,4,3.0)`. Un tentativo di accesso diretto come `A.righe = 10` non è ammesso perché `righe` si trova nella parte privata della classe, e il compilatore genererà un errore di compilazione.

## Basics - Fondamenti del Linguaggio

### Hello World

Il programma più semplice in C++ è il classico "Hello World". Questo programma inizia con la direttiva al preprocessore `#include <iostream>` che include la libreria per l'input/output. La funzione `main()` è una free function che rappresenta il punto di ingresso del programma. Il tipo restituito è un `int` che rappresenta lo status code: zero indica successo, mentre un valore diverso da zero indica un fallimento. Per accedere ai nomi del namespace standard si utilizza il prefisso `std::`. L'oggetto `cout` è un oggetto speciale che rappresenta lo schermo, mentre l'operatore `<<` è l'operatore di output che permette di inviare dati verso `cout`.

### Parametri a Riga di Comando

È possibile accedere ai parametri forniti a riga di comando definendo la funzione `main` con la seguente firma: `int main (int argc, char* argv[])`. Il parametro `argc` rappresenta il numero di parametri passati, incluso il nome del programma stesso. Il parametro `argv` è un array di stringhe in stile C che contiene i parametri effettivi.

Consideriamo un esempio concreto: se eseguiamo il programma con il comando `./myprog -a myfile.txt`, avremo che `argc` vale 3, `argv[0]` contiene la stringa `"./myprog"`, `argv[1]` contiene `"-a"`, `argv[2]` contiene `"myfile.txt"`, e `argv[3]` vale 0 (terminatore dell'array).

### Commenti

In C++ esistono due stili per i commenti. I commenti multi-linea utilizzano la sintassi `/* ... */` e possono estendersi su più righe. I commenti su singola riga utilizzano invece la sintassi `//` e si estendono fino alla fine della riga corrente. I commenti sono fondamentali per documentare il codice e spiegare la logica implementativa.

### Variabili

Una variabile in C++ è il nome associato a una porzione di memoria. La dichiarazione `int x;` crea una variabile di tipo intero. È possibile stampare il valore di una variabile utilizzando l'istruzione `cout << x;`. In C++ le variabili sono note come l-value (left side), ovvero valori che hanno un indirizzo di memoria associato. Questo è in contrapposizione con gli r-value (right side) che si riferiscono a valori che vengono assegnati a un l-value.

### Variabili Statiche

Un attributo di una classe in C++ può essere dichiarato statico, analogamente a quanto avviene in Java. Quando un attributo è statico esiste una sola variabile condivisa per tutti gli oggetti della classe. In C++ anche le funzioni possono avere variabili statiche: una variabile statica all'interno di una funzione viene creata alla prima chiamata della funzione e il suo valore viene mantenuto nelle successive chiamate.

Un esempio pratico è il conteggio del numero di chiamate di una funzione. Definendo una variabile statica `counter` inizializzata a zero e incrementandola ad ogni chiamata, è possibile tenere traccia di quante volte la funzione è stata invocata.

### Assegnamenti e R-value

Gli assegnamenti in C++ seguono regole precise. L'istruzione `int y;` dichiara `y` come variabile intera. L'istruzione `y = 4;` assegna il valore 4 a `y`. L'espressione `y = 2 + 5;` valuta prima la somma (che risulta 7) e poi assegna questo valore a `y`. Dichiarando una nuova variabile `int x;` e scrivendo `x = y;`, il valore 7 viene assegnato a `x`. L'assegnamento `x = x;` è perfettamente legale e assegna a `x` il suo stesso valore (7). Infine, l'espressione `x = x + 1;` valuta prima la somma `x + 1` (che risulta 8) e poi assegna questo nuovo valore a `x`.

### Cin

L'oggetto `cin` è l'opposto di `cout` e permette di leggere input dalla console. Un programma che chiede all'utente di inserire un numero utilizza `cout` per stampare il messaggio "Enter a number: ", dichiara una variabile intera `x`, utilizza `cin >> x;` per leggere il numero dalla console e assegnarlo a `x`, e infine stampa il valore inserito con un messaggio appropriato. L'operatore `>>` estrae i dati da `cin` e li assegna alla variabile specificata.

### Funzioni

Le funzioni in C++ sono blocchi di codice riutilizzabili. Una funzione chiamata `doPrint()` di tipo `void` (che non restituisce alcun valore) può stampare un messaggio sullo schermo. La funzione `main()` può invocare `doPrint()` semplicemente scrivendone il nome seguito dalle parentesi. Quando il programma viene eseguito, prima viene stampato "Starting main()", poi viene chiamata `doPrint()` che stampa "In doPrint()", e infine viene stampato "Ending main()" prima che il programma termini.

### Parametri di Funzione

Le funzioni possono accettare parametri per operare su dati diversi. Una funzione `add(int x, int y)` restituisce la somma di `x` e `y`. Una funzione `multiply(int z, int w)` restituisce il prodotto di `z` e `w`. Nella funzione `main` è possibile invocare queste funzioni in vari modi: con valori letterali come `add(4, 5)`, con variabili come `add(a, b)` dove `a` e `b` sono state precedentemente dichiarate, o con chiamate annidate come `add(1, multiply(2, 3))` dove il risultato di `multiply(2, 3)` viene passato come secondo parametro ad `add`.

### Forward Declaration

In C++ il compilatore legge il codice dall'alto verso il basso, quindi una funzione deve essere dichiarata prima di essere utilizzata. Se vogliamo chiamare una funzione `add` nella funzione `main` ma definire il corpo di `add` dopo `main`, dobbiamo utilizzare una forward declaration (dichiarazione anticipata). Questa consiste nel dichiarare il prototipo della funzione prima di `main` scrivendo `int add(int x, int y);`. In questo modo il compilatore sa che la funzione esiste e può compilare correttamente la chiamata in `main`, anche se l'implementazione effettiva della funzione viene fornita successivamente nel codice.

## Dati Primitivi

I tipi di dati primitivi in C++ includono `char` per i caratteri singoli, `int`, `short` e `long` per i numeri interi di diverse dimensioni, `double` e `float` per i numeri in virgola mobile, e `bool` per i valori booleani. Nel vecchio C++ gli interi venivano spesso utilizzati per rappresentare valori booleani: qualsiasi valore diverso da zero era considerato vero, mentre zero era considerato falso.

Un esempio di questa pratica è dichiarare una variabile intera `a`, leggerla con `cin`, e poi utilizzarla in una condizione `if (a)` che è equivalente a scrivere `if (a != 0)`. Similmente, quando si lavora con puntatori, un'istruzione come `while (p)` è equivalente a `while (p != 0)`, dove zero rappresenta il puntatore nullo (in C++98 si usava 0, mentre nelle versioni più recenti si usa `nullptr`).